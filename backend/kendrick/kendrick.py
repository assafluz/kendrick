import os
import codecs
import csv
from flask import Flask, request, jsonify, send_file, send_from_directory
from google.cloud import translate_v2 as translate
from google.oauth2 import service_account
from werkzeug.utils import secure_filename
from dotenv import load_dotenv
from flask_cors import CORS

# Load environment variables from .env file
load_dotenv()

# Initialize Flask app and serve static files from the correct folder
app = Flask(__name__, static_folder='../../frontend', static_url_path='')

CORS(app)  # Enable CORS for all routes

# Google Cloud Translate configuration
credentials_path = os.getenv('GOOGLE_APPLICATION_CREDENTIALS')
credentials = service_account.Credentials.from_service_account_file(credentials_path)
translate_client = translate.Client(credentials=credentials)

# Allowed file extensions for upload
ALLOWED_EXTENSIONS = {'strings', 'txt', 'csv'}

# Path for temporary file uploads
UPLOAD_FOLDER = '/tmp'
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

# Serve index.html at the root URL
@app.route('/')
def serve_index():
    return send_from_directory(app.static_folder, 'index.html')

# Serve other static files like app.js
@app.route('/<path:filename>')
def serve_static_files(filename):
    return send_from_directory(app.static_folder, filename)

# Translate file endpoint
@app.route('/translate', methods=['POST'])
def translate_file():
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400

    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400

    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)

        try:
            # Save uploaded file
            file.save(file_path)

            # Get the selected language from form data
            selected_language = request.form.get('language')  # This is now correctly passed from the frontend

            # Process based on file type
            file_ext = filename.rsplit('.', 1)[1].lower()
            if file_ext == 'strings':
                return process_strings_or_txt_file(file_path, filename, selected_language)
            elif file_ext == 'txt':
                return process_strings_or_txt_file(file_path, filename, selected_language)
            elif file_ext == 'csv':
                return process_csv_file(file_path, filename, selected_language)

        except Exception as e:
            return jsonify({"error": f"File processing error: {str(e)}"}), 500

    return jsonify({"error": "Invalid file type"}), 400

def process_strings_or_txt_file(file_path, filename, selected_language):
    translated_content = []

    try:
        with codecs.open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
    except UnicodeDecodeError:
        with codecs.open(file_path, 'r', encoding='ISO-8859-1') as f:
            lines = f.readlines()

    # Modify the header if it exists
    for idx, line in enumerate(lines):
        if "lproj" in line:
            # Modify the language code and change "Generated by Loko" to "Generated by Kendrick"
            translated_content.append(f"/*{selected_language}.lproj Translations\n")
        elif "Generated by Loko" in line:
            translated_content.append("Generated by Kendrick\n")
        elif "=" in line:
            # Process the translation part (right-hand side of =)
            key, value = line.split('=', 1)
            key = key.strip()  # Keep the key (left side) unchanged
            value = value.strip().strip(';').strip('"')  # Clean the value (right side)

            # Translate the right-hand side (value) to the selected language
            translated_value = translate_client.translate(value, target_language=selected_language)['translatedText']

            # Rebuild the line with the original left side and translated right side
            translated_line = f'{key} = "{translated_value}";\n'
            translated_content.append(translated_line)
        else:
            # Keep other lines unchanged
            translated_content.append(line)

    # Save the translated file as .strings or .txt
    translated_filename = f'translated_{filename}'
    translated_file_path = os.path.join(app.config['UPLOAD_FOLDER'], translated_filename)

    with open(translated_file_path, 'w', encoding='utf-8') as f:
        f.writelines(translated_content)

    # Send translated file back to client
    return send_file(translated_file_path, as_attachment=True)

def process_csv_file(file_path, filename, selected_language):
    translated_rows = []

    try:
        # Attempt to read CSV file in utf-8
        with open(file_path, 'r', encoding='utf-8') as csvfile:
            csv_reader = csv.reader(csvfile)
            header = next(csv_reader)  # Read header row
            translated_rows.append(header)  # Keep header

            for row in csv_reader:
                # Assuming the last column is to be translated (adjust if needed)
                original_value = row[-1]
                translated_value = translate_client.translate(original_value, target_language=selected_language)['translatedText']
                row[-1] = f'{translated_value}'  # Replace the right-hand side with translation
                translated_rows.append(row)

    except UnicodeDecodeError:
        # Fallback to ISO-8859-1 encoding if utf-8 fails
        with open(file_path, 'r', encoding='ISO-8859-1') as csvfile:
            csv_reader = csv.reader(csvfile)
            header = next(csv_reader)  # Read header row
            translated_rows.append(header)  # Keep header

            for row in csv_reader:
                # Assuming the last column is to be translated (adjust if needed)
                original_value = row[-1]
                translated_value = translate_client.translate(original_value, target_language=selected_language)['translatedText']
                row[-1] = f'{translated_value}'  # Replace the right-hand side with translation
                translated_rows.append(row)

    # Save the translated CSV file
    translated_filename = f'translated_{filename}'
    translated_file_path = os.path.join(app.config['UPLOAD_FOLDER'], translated_filename)

    with open(translated_file_path, 'w', newline='', encoding='utf-8') as csvfile:
        csv_writer = csv.writer(csvfile)
        csv_writer.writerows(translated_rows)

    # Send translated CSV file back to client
    return send_file(translated_file_path, as_attachment=True)

if __name__ == "__main__":
    app.run(port=8089, debug=True)
