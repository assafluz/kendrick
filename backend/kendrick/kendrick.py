import os
import codecs
import csv
import zipfile
import json
from flask import Flask, request, jsonify, send_file, send_from_directory
from google.cloud import translate_v2 as translate
from google.oauth2 import service_account
from werkzeug.utils import secure_filename
# from dotenv import load_dotenv
from flask_cors import CORS

# Load environment variables from .env file
# load_dotenv()

# Initialize Flask app and serve static files from the correct folder
app = Flask(__name__, static_folder='../../frontend', static_url_path='')

CORS(app)  # Enable CORS for all routes

# Google Cloud Translate configuration
credentials_path = '/Users/assaf/Documents/tinytap-1145-116c6402cb5f.json'  # Set this to the actual path of your Google Cloud credentials file
credentials = service_account.Credentials.from_service_account_file(credentials_path)
translate_client = translate.Client(credentials=credentials)

# Allowed file extensions for upload
ALLOWED_EXTENSIONS = {'strings', 'txt', 'csv'}

# Path for temporary file uploads
UPLOAD_FOLDER = '/tmp'
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

# Serve index.html at the root URL
@app.route('/')
def serve_index():
    return send_from_directory(app.static_folder, 'index.html')

# Serve other static files like app.js
@app.route('/<path:filename>')
def serve_static_files(filename):
    return send_from_directory(app.static_folder, filename)

# Translate file endpoint
@app.route('/translate', methods=['POST'])
def translate_file():
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400

    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400

    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)

        try:
            # Save uploaded file
            file.save(file_path)

            # Get selected languages from form data
            selected_languages = json.loads(request.form.get('languages', '[]'))

            if not selected_languages:
                return jsonify({"error": "No languages selected"}), 400

            # Process based on file type
            file_ext = filename.rsplit('.', 1)[1].lower()
            if file_ext in ['strings', 'txt']:
                return process_strings_or_txt_file(file_path, filename, selected_languages)
            elif file_ext == 'csv':
                return process_csv_file(file_path, filename, selected_languages)

        except Exception as e:
            return jsonify({"error": f"File processing error: {str(e)}"}), 500

    return jsonify({"error": "Invalid file type"}), 400

def process_strings_or_txt_file(file_path, filename, languages):
    translated_files = []

    # Read the file content
    try:
        with codecs.open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
    except UnicodeDecodeError:
        with codecs.open(file_path, 'r', encoding='ISO-8859-1') as f:
            lines = f.readlines()

    for language in languages:
        translated_content = []

        # Modify the header if it exists and process the translations
        for line in lines:
            if "lproj" in line:
                # Modify the language code and change "Generated by Loko" to "Generated by Kendrick"
                translated_content.append(f"/*{language}.lproj Translations\n")
            elif "Generated by Loko" in line:
                translated_content.append("Generated by Kendrick\n")
            elif "=" in line:
                # Process the translation part (right-hand side of =)
                key, value = line.split('=', 1)
                key = key.strip()  # Keep the key (left side) unchanged
                value = value.strip().strip(';').strip('"')  # Clean the value (right side)

                # Translate the right-hand side (value) to the selected language
                translated_value = translate_client.translate(value, target_language=language)['translatedText']

                # Rebuild the line with the original left side and translated right side
                translated_line = f'{key} = "{translated_value}";\n'
                translated_content.append(translated_line)
            else:
                # Keep other lines unchanged
                translated_content.append(line)

        # Save the translated file for each language
        translated_filename = f'translated_{language}_{filename}'
        translated_file_path = os.path.join(app.config['UPLOAD_FOLDER'], translated_filename)

        with open(translated_file_path, 'w', encoding='utf-8') as f:
            f.writelines(translated_content)

        translated_files.append(translated_file_path)

    # Zip the translated files
    zip_filename = 'translated_files.zip'
    zip_file_path = os.path.join(app.config['UPLOAD_FOLDER'], zip_filename)

    with zipfile.ZipFile(zip_file_path, 'w') as zipf:
        for file in translated_files:
            zipf.write(file, os.path.basename(file))

    # Send the zip file back to client
    return send_file(zip_file_path, as_attachment=True)

def process_csv_file(file_path, filename, languages):
    translated_files = []

    for language in languages:
        translated_rows = []

        try:
            # Attempt to read CSV file in utf-8
            with open(file_path, 'r', encoding='utf-8') as csvfile:
                csv_reader = csv.reader(csvfile)
                header = next(csv_reader)  # Read header row
                translated_rows.append(header)  # Keep header

                for row in csv_reader:
                    # Assuming the last column is to be translated (adjust if needed)
                    original_value = row[-1]
                    translated_value = translate_client.translate(original_value, target_language=language)['translatedText']
                    row[-1] = f'{translated_value}'  # Replace the right-hand side with translation
                    translated_rows.append(row)

        except UnicodeDecodeError:
            # Fallback to ISO-8859-1 encoding if utf-8 fails
            with open(file_path, 'r', encoding='ISO-8859-1') as csvfile:
                csv_reader = csv.reader(csvfile)
                header = next(csv_reader)  # Read header row
                translated_rows.append(header)  # Keep header

                for row in csv_reader:
                    # Assuming the last column is to be translated (adjust if needed)
                    original_value = row[-1]
                    translated_value = translate_client.translate(original_value, target_language=language)['translatedText']
                    row[-1] = f'{translated_value}'  # Replace the right-hand side with translation
                    translated_rows.append(row)

        # Save the translated CSV file for each language
        translated_filename = f'translated_{language}_{filename}'
        translated_file_path = os.path.join(app.config['UPLOAD_FOLDER'], translated_filename)

        with open(translated_file_path, 'w', newline='', encoding='utf-8') as csvfile:
            csv_writer = csv.writer(csvfile)
            csv_writer.writerows(translated_rows)

        translated_files.append(translated_file_path)

    # Zip the translated files
    zip_filename = 'translated_files.zip'
    zip_file_path = os.path.join(app.config['UPLOAD_FOLDER'], zip_filename)

    with zipfile.ZipFile(zip_file_path, 'w') as zipf:
        for file in translated_files:
            zipf.write(file, os.path.basename(file))

    # Send the zip file back to client
    return send_file(zip_file_path, as_attachment=True)

if __name__ == "__main__":
    app.run(port=8089, debug=True)
